## WebGL 进入三维世界
### 视图矩阵（view matrix）

确定观察者的状态的三个矢量

1. 视点(eye point)即观察者所在的三维空间中位置，视线的起点。
2. 观察目标点(target point) 即被观察目标所在的点。只有同时知道观察目标点和视点，才能算出视线方向。
3. 上方向(up direction)，最终绘制在屏幕上的影像中的向上方向。

视点，观察目标点和上方向三个矢量可创建出一个视图矩阵。
```c
//(视点，观察目标点，上方向)
const eye = [0,9,9];
const target = [0,0,0];
const up = [0,1,0];
m4.lookAt(eye,target,up);
```



### 模型矩阵（model matrix）

```c
如果想旋转图形，就需要用旋转矩阵乘以旋转前的顶点坐标：

<旋转后顶点坐标> = <旋转矩阵> * <原始顶点坐标>


用视图矩阵乘以旋转后的顶点坐标，就可以获得 "从视点看上去" 的旋转后的顶点坐标：

<从视点看上去的旋转后顶点坐标> = <视图矩阵> * <旋转矩阵> * <原始顶点坐标>


除了旋转矩阵，还可以用平移、缩放等基本变换矩阵或它们的组合，这时矩阵被称为模型矩阵（model matrix）。这样就可以写成：

<从视点看上去变换后的顶点坐标> = <视图矩阵> * <模型矩阵> * <原始顶点坐标>
```



### 模型视图矩阵

```c
视图矩阵和模型矩阵相乘的积被称为模型视图矩阵（model view matrix）。变换后结果可写为：

<模型视图矩阵> = <视图矩阵> * <模型矩阵>

<从视点看上去变换后的顶点坐标> = <模型视图矩阵> * <顶点坐标>
```



### 可视空间

除了水平和垂直范围内的限制，WebGL还限制观察者的可是深度，即"能够看多远"。所有这些限制，包括水平视角、垂直视角、可视深度，定义了可视空间。如果我们没有显示地指定可视空间，默认的可视深度又不够远，所以有些图形某些部分看不到。

有两种类型的可视空间：

1. 长方形可视空间，也称盒状空间，由正射投影(orthogrphic projection)产生。
2. 四棱锥/金字塔可是空间，由透视投影(perspective projection)产生。



#### 盒状可视空间

盒状可视空间由前后两个矩形表面确定，分别称为近裁剪面(near clipping plane)和远裁剪面(far clipping plane)

1. 近截面四个顶点为:

   （right、top、-near）

   （-left、top、-near）

   （-left、-bottom，-near）

   （right、-bottom、-near）

2. 远截面四个顶点为:
   （right、top、far）

   （-left、top、far）

   （-left，-bottom、far）

   （right、-bottom、far）。

```c
//正视投影 (left,right,bottom,top,near,far), 组成一个正方体的可视空间 
m4.ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 1.0);
```



#### 透视投影可视空间

就像盒状可视空间那样，透视投影可视空间也有视点、视线、近裁剪面、远裁剪面。

不论是透视投影可视空间还是盒状可视空间，我们都用投影矩阵来表示它，但是定义矩阵的参数不同。

定义了透视投影可视空间的矩阵被称为透视投影矩阵(perspective projection matrix)
```c
//透视投影矩阵(fov可视空间底面和顶面夹角<大于0>,近裁截面宽高比,近裁截面位置<大于0>,远裁截面位置<大于0>)
m4.perspective(30 * Math.PI/180, canvas.width/canvas.height, 1, 100);
```



#### 投影矩阵的运算

```c
如果程序涉及两个矩阵。在顶点着色器中，我们需要用视图矩阵乘以顶点坐标，得到顶点在视图坐标系下的坐标，再左乘投影矩阵并赋值给gl_Position。计算过程如下：

<投影矩阵> * <视图矩阵> * <模型矩阵> * <顶点坐标>

其中投影视图模型矩阵相乘后被称为 <投影视图模型矩阵矩阵>

<mvp矩阵> = <投影矩阵> * <视图矩阵> * <模型矩阵>
```





