## WebGL 绘制

### 什么是插值

插值是离散函数逼近的重要方法，利用它可通过函数在有限个点处的取值状况，估算出函数在其他点处的近似值。因为对计算机来说，屏幕像素是离散的而不是连续的，计算机图形学常用插值来填充图像像素之间的空隙。

### 什么是着色器

WebGL有两种着色器：

1. 顶点着色器(Vertex shader)：顶点着色器是用来描述顶点特性（如位置、尺寸等）的程序。顶点(vertext)是指二维或三维空间中的一个点，比如二维或三维图形的端点或交点

2. 片元着色器(Fragment shader)：进行片元处理过程如光照的程序。 片元（fragment）是一个WebGL术语，你可以将其理解为像素（图像的单元）

   

### vec4函数

我们在使用WebGL时，会给顶点着色器参数赋值，gl_Position的数据类型为vec4，gl_Position = vec4(0.0, 0.0, 0.0, 1.0)。

但实际需要的位置坐标只有三个(x,y,z)值。WebGL提供了vec4函数，由4个分量组成的矢量被称为齐次坐标，他能够提高三维数据的效率，在三维图形系统大量使用。

如果最后一个分量设置为1.0，那么齐次坐标可以表示前三个分量为坐标值的那个点。所有当需要用齐次坐标表示顶点时，只需要将最后一个分量设置为1.0就可以了。



### 变量

将信息从javascript程序中传给顶点着色器。有两种方式可做到：attribute变量和uniform变量。

* attribute 变量 传输的顶点坐标数据
* uniform 变量 传输的是所有顶点相同的数据(数据信息与顶点无关，比如变换矩阵)

```c
 //限定符，类型(4个浮点数的矢量)，变量名称。attribute变量传输与顶点有关的数据，表示逐顶点的信息(顶点依次传递给它的意思)
 attribute vec4 a_Position

 //限定符，类型 变量名称。uniform变量传输的是所有顶点都相同的数据 (各顶点或片元共用的数据，比如矩阵变换), 可以是除了数组和结构体外的任意类型
 uniform vec4 u_Translation; 

 //获取attribute变量的存储位置
 var a_Position = gl.getAttribLocation(gl.program, 'a_Position');

 //给顶点位置设置值
 gl.vertexAttrib3f(a_Position, 0.0, 0.0, 0.0);
```



### 获取attribute变量地址

gl.getAttribLocation(program, name) 

参数：

* program: 指定包含顶点着色器和片元着色器的着色器程序对象
* name: 想要获取存储地址的attribute变量的名称
* 返回值：大于等于0，attribute变量的存储地址；小于0，指定的attribute变量不存在



### 向location位置的attribute变量赋值

gl.vertexAttrib4f(location, v0, v1, v2, v3)  

参数：

* location: 指定将要修改的attribute变量的存储位置
* v0: attribute变量的第一个分量的值
* v1: attribute变量的第二个分量的值
* v2: attribute变量的第三个分量的值
* v3: attribute变量的第四个分量的值



### 获取uniform变量地址

gl.getUniformLocation(program, name) 

参数：

* program:指定包含顶点着色器和片元着色器的着色器程序对象
* name: 想要获取存储地址的uniform变量的名称
* 返回值：
  * notNull，指定的uniform变量的位置；
  * null，指定的uniform变量不存在，或者其命名以gl_或者webgl_前缀。
  * 说明：getUniformLocation和getAttribLocation 区别在于为null 和-1，如果变量不存在时。



### 向location位置的uniform变量赋值

gl.uniform4f(location, v0, v1, v2, v3) 参数与vertexAttrib4f函数参数相似。

gl.uniform4fv(location, [v0, v1, v2, v3]) 参	数是以数组的形式传入。

gl.uniformMatrix4fv(location, transpose, array) 将array表示的4\*4矩阵分配给由location指定的uniform变量。参数：

* location:uniform变量的存储位置。
* Transpose：在WebGL中必须指定为false
* array:带传输的类型化数组，4\*4矩阵按列主序存储在其中



### 缓冲区对象向顶点着色器传入顶点的数据的五个步骤

1. 创建缓冲区对象 gl.createBuffer()。   
2. 绑定缓冲区对象 gl.bindBuffer()。
3. 将数据写入缓冲区对象 gl.bufferData()。
4. 将缓冲区对象分配给一个attribute变量 gl.vertexAttribPointer()。
5. 开启attribute变量 gl.enableVertexAttribArray()。



#### 创建缓冲区对象 

gl.createBuffer()

使用WebGL时，需要调用gl.createBuffer()方法来创建缓冲区对象。

对应createBuffer的是gl.deleteBuffer(buffer)函数，用来删除创建的缓冲区对象。buffer表示带删除的缓冲区对象。



#### 绑定缓冲区 

gl.bindBuffer(target, buffer)

将缓冲区对象绑定到WebGl系统中已经存在的“目标”（target）上。执行绑定后，WebGL系统内部状态发生变化。

参数：

* target:绑定的目标。可以使以下中的一个：
      gl.ARRAY_BUFFER,表示缓冲区对象中包含了顶点的数据;
      gl.ELEMENT_,表示缓冲区对象中包含了顶点的索引值。
  
* buffer：指定之前由gl.createBuffer()返回的带绑定的缓冲区对象。



#### 向缓冲区对象中写入数据 

gl.bufferData(target, data, usage)

开辟存储空间，想绑定在target上的缓冲区对象总写入数据data。

参数：

* target: gl.ARRAY_BUFFER 或 gl.ELEMENT_ARRAY_BUFFER。
* data: 写入缓冲区对象的数据。
* usage: 表示程序将如何使用存储在缓冲区对象中的数据。

usage 参数值包括：
    gl.STATIC_DRAW, 只会向缓冲区对象中写入一次数据，但需要绘制很多次；
    gl.STREAM_DRAW, 只会向缓冲区对象中写入一次数据，然后绘制若干次;
    gl.DYNAMIC_DRAW, 会想缓冲区对象中多次写入数据，并绘制很多次。



#### 将缓冲区对象分配给attribute变量 

gl.vertexAttribPointer(location, size, type, normalized, stride, offset)

参数：

* location:指定带分配attribute变量的存储位置。

* size:指定缓冲区中每个顶点的分量个数（1到4）。若size比attribute变量书序的分量数小，确实分量将按照与gl.vertexAttrib[1234]f()相同的规则补全。

* type 使用以下类型之一来指定数据格式：
      gl.UNSIGNED_BYTE,  无符号字节，UInt8Array;
      gl.SHORT,          短整形，Int16Array;
      gl.UNSIGNED_SHORT, 无符号短整形，Uint16Array;
      gl.INT,            整形，Int32Array;
      gl.UNSIGNED_INT,   无符号整形，Uint32Array;
      gl.FLOAT,          浮点型，Float32Array。

* normalize:传入true或false，标明是否将非浮点型的数据归纳化到[0,1]或[-1,1]区间。

* stride:指定相邻两个顶点间的字节数，默认为0。

  ```c
  // 每个元素的字节
  var FSIZE = verticeSizeColors.BYTES_PER_ELEMENT;
  stride = FSIZE*num;
  ```

* offset：指定缓冲区对象中的偏移量以字节为单位。如果是起始位置，则offset为0。
  offset = FSIZE*num;

  

#### 开启attribute变量 

gl.enableVertexAttribArray(location)

为了使定点着色器能够访问缓冲区内的数据，需要使用gl.enableVertexAttribArray()方法开启attribute变量。



#### 将矩阵传递给对象缓冲区 

gl.uniformMatrix4fv(location, transpore, array)

将array表示的4*4矩阵分配给有location指定的uniform变量。

参数：

* location:uniform变量的存储位置
* Transpose:在WebGL中必须指定为false
* array:带传输的类型化数组，4*4矩阵按例主序存储在其中



### 通过元素索引绘制

gl.drawArrays(mode, first, count)

参数：

```c
mode: //基本图形项可以生成点，线，三角形，矩形，扇形等
  gl.POINTS //点
  gl.LINES //线段
  gl.LINE_STRIP //线条
  gl.LINE_LOOP //回路
  gl.TRIANGLES //三角形
  gl.TRIANGLE_STRIP //三角带
  gl.TRIANGLE_FAN //三角扇

first://指定从哪个顶点开始绘制（整型）
count://指定绘制需要用到多少个顶点（整型）
```



### 通过顶点索引绘制

gl.drawElements(mode, count, type, offset)

执行着色器，按照mode参数指定的方式，根据绑定到 gl.ELEMENT_ARRAY_BUFFER的缓冲区中的顶点索引值绘制图形。参数：

```c
mode: //指定绘制的方式，可接收以下常量符号：
    gl.POINTS、
    gl.LINES、
    gl.LINE_STRIP、
    gl.LINE_LOOP、
    gl.TRIANGLES、
    gl.TRIANGLES_STRIP、
    gl.TRIANGLES_FAN

count:  // 指定绘制顶点的个数（整形数）
type:   // 指定索引数组类型：gl.UNSIGNED_BYTE, gl.UNSIGNED_SHORT 或 gl.UNSIGNED_INT
offset: // 指定索引数组开始绘制的位置，以字节为单位
```



### 读取像素值 

gl.readPixels(x, y, width, height, format, type, pixels)

从颜色缓冲区中读取由x、y、width、height参数确定的矩形块中的所有像素值，并保存在pixels指定的数组中。

```c
gl.readPixels(x, y, width, height, format, type, pixels) 参数：

x,y: //指定颜色缓冲区中矩形块左上角的坐标，同时也是读取的第一个像素的坐标
width，height: //指定矩形块的宽度和高度，以像素为单位
format: //指定像素值颜色格式，必须为gl.RGBA
type: //指定像素值的数据格式，必须为gl.UNSIGNED_BYTE
pixels: //指定用来接收像素数据的Uint8Array类型化数组

//读取的x,y的原点是从左下角开始，而不是从左上角开始。加入canvas长、宽分别为100、30，那么右下角的坐标为(100, 0)。
```



### 清空绘图区

缓冲区包括：

- gl.COLOR_BUFFER_BIT颜色缓冲区
- gl.DEPTH_BUFFER_BIT深度缓冲区
- gl.STENCIL_BUFFER_BIT模板缓冲区。

清理函数分别为

- gl.clearColor(red,green,blue,alpha)
- gl.clearDepth(depth)
- gl.clearStencil(s)。

```c
//设置背景色。openGL的颜色取值返回是0-1。
gl.clearColor(red, green, blue, alpha) 

//用clearColor指定的背景色清空绘图区域。清理绘图区域实际上在清理颜色缓冲区（color buffer），传递的gl.COLOR_BUFFER_BIT就是在告诉WebGL清理颜色缓冲区。
gl.clear(gl.COLOR_BUFFER_BIT) 

//可以用位or(|)指定多个缓冲区
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
```



### 设置绘图区域

gl.viewport(x, y, width, height)
设置 gl.drawArrays() 和 gl.drawElements()函数的绘图区域。参数：

- x,y:指定绘图区域的左上角，以像素为单位
- width,height：指定绘图区域的宽度和高度



### 画布大小

canvas.clientHeight 和 canvas.clientWidth

大多数程序在画布大小改变时都会保持canvas.width 和 canvas.height 与 canvas.clientWidth 和 canvas.clientHeight 一致，因为他们希望屏幕一像素对应绘制一像素。

但那并不是唯一的选择，也就是说在大多数情况下正确的做法是用canvas.clientHeight 和 canvas.clientWidth来计算长宽比



### 启用功能 

gl.enable(cap) 

```c
cap（capability）指定需要开启的功能参数, 有可能是以下几个：
gl.DEPTH_TEST //隐藏面消除
g.BLEND //混合
gl.POLYGON_OFFSET_FILL //多边形移位
```

gl.diable(cap) 与 gl.enable (cap) 相同



### 隐藏面消除

WebGL提供了隐藏面消除（hidden surface removal）功能。这个功能会帮助我们消除那些被遮挡的表面（隐藏面），你可以放心地绘制场景而不必估计个物体在缓冲区中的顺序。开启隐藏面消除功能步骤如下：

```c
// 1. 开启隐藏面消除功能
gl.enable(gl.DEPTH_TEST);

// 2. 在绘制之前，清除深度缓冲区
gl.clear(gl.DEPTH_BUFFER_BIT);

//在清理深度缓冲区的同时还要清理颜色缓冲区，所有可以用按位或（|）连接gl.DEPTH_BUFFER_BIT和gl.COLOR_BUFFER_BIT:
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
```



### 剔除面

WebGL中的三角形有正反面的概念，默认正面三角形的顶点组绕顺序是顺时针方向(CW)， 反面三角形是逆时针方向(CCW)。开启这个特性后WebGL默认"剔除"背面三角形， "剔除"在这里是"不绘制"的意思。

对于WebGL而言，一个三角形是顺时针还是逆时针是根据裁剪空间中的顶点顺序判断的， 换句话说，WebGL是根据你在顶点着色器中运算后提供的结果来判定的，这就意味着如果你把一个顺时针的三角形沿 X 轴缩放 -1 ，它将会变成逆时针，或者将顺时针的三角形旋转180度后变成逆时针。

```c
//可剔除的面
gl.FRONT
gl.BACK
gl.FRONT_AND_BACK

//WebGL开启面剔除功能，默认剔除背面
gl.enable(gl.CULL_FACE);

gl.frontFace(gl.CW);//指定顺时针为正面
gl.frontFace(gl.CCW);//指定逆时针组绕的三角形是正面三角形

//剔除正反面
gl.cullFace(gl.FRONT_AND_BACK);
```



### 退化三角形

当三角形带之间不连续，存在跳转的解决办法就是插入额外索引(drawElements) 或插入额外顶点(drawArrays)，这样就得到退化三角形。退化三角形是指至少有两个索引(顶点)相同的，存在面积为0的三角形。这种很容易被GPU检测并删除。

连接两个三角形带需要额外索引的数量取决于第一个三角形带所使用的索引数。

- 如果包含偶数个三角形，则需要增加两个额外索引(第一个三角形带最后一个索引，第二个三角形带第一个索引)
- 如果包含奇数个三角形，则需要增加三个额外索引(第一个三角形带最后两个索引，第二个三角形带第一个索引)



### 深度冲突（Z fighting）

当几何图形或物体的两个表面极为接近时，使得表面看上去斑斑驳驳的。这种现象被称为深度冲突。

WebGL提供一种被称为多边形偏移（polygon offset）机制解决这个问题。该机制自动在Z值加上一个偏移量。启动该机制只需要两行代码：

```c
// 1.启动多边形编译
gl.enable(gl.POLYGON_OFFSET_FILL);

// 2.在绘制之前指定用来计算偏移量的参数
gl.polygonOffset(1.0, 1.0);
```

gl.polygonOffset(factor, units)

指定加到每个顶点绘制后的Z值上的偏移量，偏移量按照公式"m \* factor+r \* units"计算，
其中m表示顶点所在表面相对于观察者的视线的角度，
而r表示硬件能够区分两个z值之差的最小值。