## WebGL 光照
### 着色（shading）

在三维图形学术语"着色"的真正含义就是，根据光照条件重建"物体各表面明暗不一的效果"的过程。明白着色过程，需要考虑两件事：

1. 发出光线的光源类型
2. 物体表面如何反射光线



### 光源类型

真实世界中的光主要有两种: 

1. 平行光（directional light），类似于自然中的太阳光；
2. 点光源光（point light），类似于人造灯泡的光。



我们可用环境光（ambient light）来模拟真实世界中的非直射光（也就是由光源发出后经过墙壁或其他物体反射后的光）。



### 反射类型

物体表面反射光线的方式：

1. 漫反射（diffuse reflection）
2. 环境反射（enviroment ambient reflection）
3. 镜面反射 (specular reflection)

```c
//当漫反射,环境反射和镜面反射同时存在时，将它们加起来就得到物体最终被观察到的颜色：
<表面的反射光颜色> = <漫反射光颜色> + <环境反射光颜色> + <镜面反射光颜色>
```



#### 漫反射

在漫反射中，反射光的颜色取决于入射光的颜色、表面的基底色、入射光与表面形成的入射角。我们将入射角定义为入射光与表面的法线形成的夹角，并用θ表示。

```c
//漫反射的颜色可根据下式计算得到：
<漫反射光颜色> = <入射光颜色> * <表面基底色> * cos θ
```



#### 环境反射

```c
//环境反射光颜色计算根据下式计算得到：
<环境反射光颜色> = <入射光颜色> * <表面基底色>
```



#### 根据光线和表面朝向计算入射角

我们无法预先确定光线以怎样的角度照射到每个表面上。但是，我们可以确定每个表面的朝向。在指定光源的时候，再确定光的方向，就可以用着两项信息来计算出入射角了。

```c
//我们可以通过计算两个矢量的点积，来计算着两个矢量的夹角余弦值cosθ。我们使用点符号（.）来表示点积运算。这样就可以通过下式计算出来：
 cosθ = <光线方向> * <法线方向>

//根据漫反射光颜色计算公式，可得到：
 <漫反射光颜色> = <入射光颜色> * <表面基底色> * (<光线方向> * <法线方向>)

//特别要强调的是，光线方向和法线方向的矢量坐标都必须归一化。即矢量的长度为1。
```



#### 镜面反射

```c
<镜面反射光颜色> = <高光颜色> * <镜面反射亮度权重> 

<镜面反射亮度权重> = <反射向量> ^ 光泽度

<镜面反射亮度权重> = (<观察方向的单位向量> * <入射光反射方向>)^光泽度

<镜面反射光颜色> = <高光颜色> * (<观察方向的单位向量> * <入射光反射方向>)^光泽度

reflect(I, N) 计算反射向量，GLSL ES提供的内置函数 
 入射方向量 I
 表面法向量 N
 返回 I-2*dot(N,I)*N, N必须被归一化

// 观察方向的单位向量V
vec3 eyeDirection = normalize(-v_Position);
// 反射方向
vec3 reflectionDirection = reflect(-lightDirection, normal);

// 镜面反射亮度权重
float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), materialShininess);

// 镜面高光亮度
vec3 specular =  specularColor.rgb * specularLightWeighting * (nDotL<=0.0?0.0:1.0);
```



#### 光强衰减

真实世界中，光强衰减与 1/r•r 成正比，r是光源距离。但在计算机图形学中，常用衰减函数不同于 1/r•r，原因是它会造成光照亮度变化太大。一般使用如下衰减函数

```c
//constantAtt 衰减常量
//linearAtt 线性衰减常量
//quadraticAtt 二次方衰减常量
//r 光源距离
1/(constantAtt + linearAtt * r + quadraticAtt * r * r)
```

随着光线传播距离的增长逐渐削减光的强度通常叫做衰减(Attenuation)。随距离减少光强度的一种方式是使用一个线性方程。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而这样的线性方程通常会看起来比较假。在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。所以，我们需要一个不同的公式来减少光的强度。

幸运的是一些聪明的人已经帮我们解决了这个问题。下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：

$Fatt=1.0/(Kc+Kl∗d+Kq∗d2)$

在这里dd代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：常数项Kc、一次项Kl和二次项Kq。

- 常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。
- 一次项会与距离值相乘，以线性的方式减少强度。
- 二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。

由于二次项的存在，光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降。这样的结果就是，光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度。下面这张图显示了在100的距离内衰减的效果：

![img](https://learnopengl-cn.github.io/img/02/05/attenuation.png)

你可以看到光在近距离的时候有着最高的强度，但随着距离增长，它的强度明显减弱，并缓慢地在距离大约100的时候强度接近0。这正是我们想要的。

### 选择正确的值

但是，该对这三个项设置什么值呢？正确地设定它们的值取决于很多因素：环境、希望光覆盖的距离、光的类型等。在大多数情况下，这都是经验的问题，以及适量的调整。下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。第一列指定的是在给定的三项时光所能覆盖的距离。这些值是大多数光源很好的起始点，它们由[Ogre3D的Wiki](http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Point+Light+Attenuation)所提供：

| 距离 | 常数项 | 一次项 | 二次项   |
| :--- | :----- | :----- | :------- |
| 7    | 1.0    | 0.7    | 1.8      |
| 13   | 1.0    | 0.35   | 0.44     |
| 20   | 1.0    | 0.22   | 0.20     |
| 32   | 1.0    | 0.14   | 0.07     |
| 50   | 1.0    | 0.09   | 0.032    |
| 65   | 1.0    | 0.07   | 0.017    |
| 100  | 1.0    | 0.045  | 0.0075   |
| 160  | 1.0    | 0.027  | 0.0028   |
| 200  | 1.0    | 0.022  | 0.0019   |
| 325  | 1.0    | 0.014  | 0.0007   |
| 600  | 1.0    | 0.007  | 0.0002   |
| 3250 | 1.0    | 0.0014 | 0.000007 |

你可以看到，常数项Kc在所有的情况下都是1.0。一次项Kl为了覆盖更远的距离通常都很小，二次项Kq甚至更小。尝试对这些值进行实验，看看它们在你的实现中有什么效果。在我们的环境中，32到100的距离对大多数的光源都足够了。

在片段着色器中实现衰减还是比较直接的：我们根据公式计算衰减值，之后再分别乘以环境光、漫反射和镜面光分量。

我们仍需要公式中距光源的距离，怎么计算一个向量的长度？我们可以通过获取片段和光源之间的向量差，并获取结果向量的长度作为距离项。我们可以使用GLSL内建的length函数来完成这一点：

```c
float distance    = length(light.position - FragPos);
float attenuation = 1.0 / (light.constant + light.linear * distance + 
                light.quadratic * (distance * distance));
```

接下来，我们将包含这个衰减值到光照计算中，将它分别乘以环境光、漫反射和镜面光颜色。

我们可以将环境光分量保持不变，让环境光照不会随着距离减少，但是如果我们使用多于一个的光源，所有的环境光分量将会开始叠加，所以在这种情况下我们也希望衰减环境光照。简单实验一下，看看什么才能在你的环境中效果最好。

```c
ambient  *= attenuation; 
diffuse  *= attenuation;
specular *= attenuation;
```



#### 法向量

物体表面的朝向，即垂直于表面的方向，又称为法线或法向量。法向量有三个分量：

向量（nx, ny, nz) 表示从原点 (0, 0, 0) 指向(nx, ny, nz)的方向。

比如向量（1, 0, 0) 表示x轴正方向，向量(0, 0, 1）表示z轴正方向。   

 

#### normalize (vec3)  单位化

normalize 是 GLSL ES提供的内置函数，对矢量单位化。 每个分量按比例压缩在区间1之内，这样向量的方向不变，方便计算

```c
vec3 normal = normalize(vec3(a_Normal)); // 对法向量单位化
```



#### dot(vec1, vec2) 矢量点积

GLSL ES提供的内置函数dot() 计算两个矢量的点积，该函数接收两个矢量作为参数，返回它们的点积。

```c
 float dot = max(dot(u_LightDirection, normal), 0.0); // 计算光线方向和法向量点积

 //θ是入射角，也就是入射反方向（光线方向）与表面法线向量的夹角
 //点积值大于0，照射在正面，等于0表示平行，小于0，意味着入射角θ大于90度，光照在表面的背面，这时将点积设置为0.0，取消背面的光照。
```



### 魔法矩阵：逆转置矩阵

对顶点进行变换的矩阵称为模型矩阵。如果模型变换只包括位移，旋转，等比缩放，则可以用模型矩阵代替逆转置矩阵进行计算，但斜切拉伸挤压之类的不等比变换必须使用逆转置矩阵。

```c
// 等比例变换使用模型矩阵的3×3子矩阵 * 向量即可得到
v_normal = vec3(u_modelMatrix * a_normal);
```

那非等比例变换如何计算变换之后的法向量呢？只要将变换之前的法向量乘以模型矩阵的逆转置矩阵（inverse transpose matrix）即可。

所谓逆转置矩阵，就是逆矩阵的转置。逆矩阵的含义，如果矩阵M的逆矩阵为R，那么R\*M或M\*R的结果都是单位矩阵。转置的意思是，将矩阵的行列进行调换（看上去就像是沿着左上-右下对角线进行了翻转）。求逆转置矩阵的两个步骤：

1. 求原矩阵的逆矩阵。

2. 将上一步求得的矩阵进行转置。

```javascript
//matrix4中求逆转置矩阵
normalMatrix.setInverseOf(modelMatrix);
normalMatrix.transpose();

//m4求逆转置矩阵
m4.transpose(m4.inverse(modelMatrix))

//glsl中求逆转置矩阵(WebGL2 GLSL 300 es)
transpose(inverse(modelMatrix));
```

​       

### 逐片元光照

varying变量传输到片元着色器后的值都是在光栅化阶段中经过插值处理的。
即经过内插过程后，片元着色器获得的是逐片元的坐标  v_position 和 法向量 v_normal，不再只是单一个顶点的信息。